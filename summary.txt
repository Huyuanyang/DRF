#########DRF组件################
####认证：
#作用，检测用户是否登录
    #自定义认证类（继承自object）
    class MyBaseAuthentication(Object):
    
        def authenticate(self, request):
            #完成认证逻辑
            
        def authenticate_header(self, request):
        
            pass

    #自定义认证类（继承自BaseAuthentication）
    from rest_framework.authentication import BaseAuthentication
    from rest_framework.exceptions import AuthenticationFailed
    class MyBaseAuthentication(BaseAuthentication):
        
        def authenticate(self, request):
            #完成认证逻辑

    #局部配置配置（在视图中配置）
    # 登录用户才能访问所有注册用户列表(局部使用设置)
    authentication_classes = [MyBaseAuthentication,]

    #设置为空列表，就不走认证流程了（全局设置后，要想单个视图不走认证）
    authentication_classes = []

    #全局设置
    REST_FRAMEWORK = {
        'DEFAULT_AUTHENTICATION_CLASSES':['util.authentication.MyBaseAuthentication',],
    }

    #匿名用户（用户未登录的情况下，可以设置匿名用户信息（ user、auth））
    # 必要条件：不管是全局还是视图中都没有设置认证类
    REST_FRAMEWORK = {
        'UNAUTHENTICATED_USER':lambda :'匿名用户',
        'UNAUTHENTICATED_TOKEN':lambda :'1234',
    }

#####源码逻辑（看造化）


####权限
####作用：某些接口只能是特定的用户才能访问
####使用
     #自定义权限类（Object）
     class MyPermission(object):
         message = 'vip用户才能访问'
         def has_permission(self,request,view):
             #完成权限逻辑
             #返回True,表示有权限访问
             #返回false，表示没有权限访问

    #自定义权限类（BasePermission）
    from rest_framework.permissions import BasePermission
    class MyPermission(BasePermission):
            message = 'vip用户才能访问'
            def has_permission(self,request,view):
                #完成权限逻辑
                #返回True,表示有权限访问
                #返回false，表示没有权限访问

    #局部配置配置（在视图中配置）
    #设置权限类(局部使用设置)
    # permission_classes = [MyPermission,]

    #设置为空列表，就不走权限流程了（全局设置后，要想单个视图不走权限设置了）
    # permission_classes = []


   #全局设置
   REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES':['util.permission.MyPermission',],
   {


####节流
###作用：根据用户的ip地址用户的唯一标示限制用户的访问频率
####使用
    #自定义（Object）
    RECORD_VISITS = {}
    class VisitThrottle(object):
        def __init__(self):
            #获取用户的访问历史
            self.history = []
        
        def allow_request(self, request, view):
            #allow_request是否允许方法
            #True 允许访问
            #False 不允许访问
            #获取用户的IP地址
            # ip_address = request._request.META.get('REMOTE_ADDR')
            # key = ip_address
            
            #基于用户
            token = request.auth
            key = token
            
            currenttime = time.time()
            if key not in RECORD_VISITS:
                #当前的IP地址没有访问过服务器
                RECORD_VISITS[key] = [currenttime]
                return True
            #获取访问历史记录
            visit_history = RECORD_VISITS[key]
            self.history = visit_history
            
            #[ 12:01:00, 12:01:25, 12:02:25]            12:03:30  - 60
            #                                           12:02:30
            while visit_history and visit_history[-1] < currenttime - 60:
                visit_history.pop()

        if len(visit_history) < 5:
            #每分钟访问5次
            visit_history.insert(0,currenttime)
            return True
                
        return False  # False表示访问频率太高被限制
        
        def wait(self):
            # 12:03:03
            # [12:02:58,12:02:55,12:02:50,12:02:45,12:02:40]
            first_time = self.history[-1]
            return 60 - (time.time() - first_time)

     #自定义（SimpleRateThrottle）

    class MySimpleRateThrottle(SimpleRateThrottle):
        scope = 'unlogin'
        def get_cache_key(self, request, view):
            #根据ip或者用户标示获取用户的访问记录
            return self.get_ident(request)
            #  return request.user.name

     #局部使用
        #设置节流的类(局部使用设置)
        throttle_classes = [VisitThrottle,]
        throttle_classes = [MySimpleRateThrottle,]

        #设置为空列表，就不进行节流设置了
         throttle_classes = []

    # 全局设置
        REST_FRAMEWORK = {
            'DEFAULT_THROTTLE_RATES':{
                'unlogin':'5/m',
            },
            'DEFAULT_THROTTLE_CLASSES':['util.throttle.MySimpleRateThrottle',],
        }

#####版本
#####作用:判断用户请求的Api是否有效（公司版本迭代时做兼容）
#####使用
     自定义（object）：（url地址传参）
     class MyPathVersioning(object):
         def determine_version(self,request, *args, **kwargs):
             # 获取用户传递的版本参数（version）
             # version = request._request.GET.get('version')
             version = request.query_params.get('version')
             return version

    #设置自定义的版本类
    # versioning_class = MyPathVersioning

   # 使用DRF自带的版本类QueryParameterVersioning
   from rest_framework.versioning import QueryParameterVersioning
    # 在视图中
    versioning_class = QueryParameterVersioning

    #如果需要做版本的默认和限制，需要在settings中设置
    REST_FRAMEWORK = {
        'DEFAULT_VERSION':'v1',
        'ALLOWED_VERSIONS':['v1','v2','v3'],
        'VERSION_PARAM':'version',
    }

    # #设置默认的版本
    # default_version = api_settings.DEFAULT_VERSION
    # #设置允许的版本
    # allowed_versions = api_settings.ALLOWED_VERSIONS
    # #设置版本的参数
    # version_param = api_settings.VERSION_PARAM











